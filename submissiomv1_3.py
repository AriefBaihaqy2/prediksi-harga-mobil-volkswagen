# -*- coding: utf-8 -*-
"""Submissiomv1_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14cKxl89J5uCKc44WrUHAgjkbJObtfciw

Nama : Sukma Ramadhan Asri  
Asal : Bandung

# Prediksi Harga Mobil
## Domain proyek
Domain yang saya pilih pada proyek ini adalah **Bisnis Otomotif**.
- Persaingan di sektor industri makin tahun makin ketat dan kompetitif, sehingga perusahaan-perusahaan secara tidak langusng dituntut untuk terus berkreasi dan berinovasi dalam menawarkan produk atau jasa yang akan dijualnya
  agar setiap perusahaan, baik yang menawarkan produk ataupun jasa mempunyai tujuan untuk tetap hidup dan berkembang. Ataupun konsumen yang sudah dimiliki perusahaan tidak berpindah ke produk lain dan untuk menarik konsumen baru untuk
  mengonsumsi produk yang sudah dihasilkan suatu perusahaan. Seiring dengan ide tersebut konsep pemasaran pun turut berkembang. Kegiatan pemasaran sekarang sudah difokuskan pada pemuasan kebutuhan konsumen. Pemasaran itu sendiri
- Masalah yang harus diselesaikan adalah bagaimana caranya produk mobil tersebut dapat bersaing didunia pasar, serta dapat memprediksi harga dari produk tersebut.

Hasil riset terkait dapat dilihat dari tautan berikut:

- [tautan](http://repository.unpas.ac.id/41755/4/7.%20BAB%201.pdf)

## Business Understanding.

### Problem Statements

1. Bagaimana agar penjualan mobil tidak menurun ?
2. Bagaimana agar konsumen dapat tertarik untuk membeli mobil ?

### Goals

Membuat prediksi harga mobil agar para pembeli dapat dengan mudah memperhitungkan harga mobil pada masa mendatang

### Solution statements

Solution Statements yang akan dilakukan adalah dengan menerapkan 3 algoritma Machine Learning yaitu :

- **Random Forest**.<br>
  Algoritma random forest adalah salah satu algoritma supervised learning. Dia dapat digunakan untuk menyelesaikan masalah klasifikasi dan regresi. Random forest juga merupakan algoritma yang sering digunakan karena cukup sederhana tetapi memiliki stabilitas yang mumpuni.
- **Boosting Algorithm**.<br>
  Algoritma boosting bekerja dengan membangun model dari data latih. Kemudian Dia membuat model kedua yang bertugas memperbaiki kesalahan dari model pertama. Model ditambahkan sampai data latih terprediksi dengan baik atau telah mencapai jumlah maksimum model untuk ditambahkan.
- **K-Nearest Neighbor**.<br>
  KNN adalah algoritma yang relatif sederhana dibandingkan dengan algoritma lain. Algoritma KNN menggunakan ‘kesamaan fitur’ untuk memprediksi nilai dari setiap data yang baru. Dengan kata lain, setiap data baru diberi nilai berdasarkan seberapa mirip titik tersebut dalam set pelatihan.

pertama kali yang dilakukan yaitu import seluruh library yang akan digunakan
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import OneHotEncoder
from sklearn.decomposition import PCA
import numpy as np
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import AdaBoostRegressor

"""## Data Understanding

Data atau dataset yang digunakan pada proyek machine learning ini adalah data **100,000 UK Used Car Data set** yang didapat dari situs kaggle. Link dataset dapat dilihat dari tautan berikut [vw.csv](https://www.kaggle.com/adityadesai13/used-car-dataset-ford-and-mercedes?select=vw.csv)

Variabel-variabel pada House Sales in King County, USA dataset adalah sebagai berikut :

- model : merupakan daftar model yang ada pada mobil Volkswagen.
- year : merupakan daftar tahun dirilisnya model mobil.
- Price : merupakan daftar harga dari mobil (dalam satuan euro).
- transmission : merupakan daftar transmission pada mobil .
- mileage : merupakan daftar jarak tempuh yang dapat dilalui.
- fuelType : merupakan daftar tipe bahan bakar yang digunakan.
- tax : merupakan daftar pajak
- mpg : merupakan daftar efesiensi bahan bakar.
- engineSize : merupakan daftar kapasistas mesin.

membuat path yang isinya merupakan alamat(path) tempat file vw.csv berada.
"""

path = 'F:/DICODING/Studi independen/Submission/MachineLearningTerapan/submission1/vw.csv'
car = pd.read_csv(path)
car

"""Cek tipe data yang digunakan pada setiap kolom"""

car.info()

"""Dari data diatas dapat disimpulkan bahwa terdapat 6 data numerik yang terdiri dari column :
- year
- price
- mileage
- tax
- mpg
- engineSize

serta 3 data kategirik yang terdiri dari column :
- model
- transmission
- fuelType

Mengecek deskripsi statistik data car vw
"""

car.describe()

"""## Data Preparation

Data preparation yang digunakan oleh saya yaitu :

- Seleksi data : menyeleksi data apakah data tersebut ada yang kosong atau tidak, jika ada data kosong maka saya akan.menghapusnya
- Membagi data menjadi data training dan test : untuk membagi data untuk dilatih dan tes.

cek apakah ada data yang nilainya 0
"""

mileage =(car.mileage == 0).sum()
mpg =(car.mpg == 0).sum()
engineSize =(car.engineSize == 0).sum()


print('nilai 0 pada kolom mileage ada : ', mileage)
print('nilai 0 pada kolom mpg ada : ', mpg)
print('nilai 0 pada kolom engineSize ada : ', engineSize)

"""Dari data diatas dapat dilihat bahwa kolom engineSize memilik data 0

cek apakah data bernilai 0 pada salah satu dimensi terdapat pada dimensi lain
"""

car.loc[car['engineSize']==0]

"""#### Drop baris dengan nilai sqft_above, sqft_living, sqft_basement, sqft_lot, serta memastikan bahwa baris sudah didrop"""

car = car.loc[(car[['mileage','mpg','engineSize']]!=0).all(axis=1)]
car.shape

"""Cek kembali Deksripsi statistik data"""

car.describe()

"""### Menangani outliers

Memviusalisasikan car dengan bloxplot untuk mendeteksi ouliers pada numerik

Visualisasi bloxplot untuk column mileage
"""

sns.boxplot(x=car['mileage'])

"""Visualisasi bloxplot untuk column tax"""

sns.boxplot(x=car['tax'])

"""Visualisasi bloxplot untuk column mpg"""

sns.boxplot(x=car['mpg'])

"""Visualisasi bloxplot untuk column engineSize"""

sns.boxplot(x=car['engineSize'])

"""Mengani outliers dengan persamaan:   
<i> Batas bawah = Q1 - 1.5 * IQR</i>    
<i> Batas atas = Q3 + 1.5 * IQR</i>
"""

Q1 = car.quantile(0.25)
Q3 = car.quantile(0.75)
IQR = Q3-Q1
car=car[~((car<(Q1-1.5*IQR))|(car>(Q3+1.5*IQR))).any(axis=1)]

car.shape

"""Proses analisi data dengan teknik univariate EDA, dengan membagi fitur manjadi 2 yaotu numerik dan kategorikal"""

numerik = ['year','price','mileage','tax','mpg','engineSize']
kategorikal = ['model','transmission','fuelType']

"""### Analisis terhadap fitur kategori  

**FITUR MODEL**
"""

feature = kategorikal[0]
count = car[feature].value_counts()
percent = 100*car[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature)

"""**FITUR TRANSMISSION**"""

feature = kategorikal[1]
count = car[feature].value_counts()
percent = 100*car[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature)

"""**FITUR ENGINETYPE**"""

feature = kategorikal[2]
count = car[feature].value_counts()
percent = 100*car[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature)

"""### Numerikal
melihat histogram masing-masing fitur numerikal yaitu year, price, mileage, tax, mpg dan engineSize
"""

car.hist(bins=50, figsize=(20,15))
plt.show()

"""### Exploratory Data Analysis - Multivariate Analysis
melakukan analisis data pada fitur kategori dan numerik.

***KATEGORI***  
Mengecek rata-rata price terhadap masing-masing fitur untuk mengetahui pengaruh fitur terhadap price
"""

kategori_features = car.select_dtypes(include='object').columns.to_list()
for col in kategori_features:
    sns.catplot(x=col, y='price', kind='bar', dodge=False, height = 7, aspect= 3, data=car, palette='Set3')
    plt.title('Rata-rata "price" relatif terhadap - {}'.format(col))

"""Dengan mengamati rata-rata harga relatif terhadap fitur kategori di atas, kita memperoleh insight sebagai berikut:
<ul>
    <li>Pada fitur ‘model’, rata-rata harga cenderung berbeda. Rentangnya berada antara 500 hingga 30000. Grade tertinggi yaitu grade up memiliki harga rata-rata terendah diantara grade lainnya. Sehingga, fitur model memiliki pengaruh atau dampak yang kecil terhadap rata-rata harga.</li>
    <li>Pada fitur ‘transmission’, transmission manual merupakan transmission yang paling rendah dan harganya pun rendah dibanduing dengan transmission automatic dan semi-auto, hal ini berarti bahwa fitur transmission memiliki pengaruh yang tinggi terhadap harga</li>
    <li>Pada fitur ‘fuelType’, secara umum, fueltype yang gradenya lebih tinggi memiliki harga yang tinggi juga, hal ini berati bahwa fitur fuelType memiiki pengaruh yang tinggi terhadap harga.</li>
    <li>Kesimpulan akhir, fitur kategori memiliki pengaruh yang tinggi terhadap harga.</li>
</ul>

**Numerikal**  
mengobservasi korelasi antara fitur numerik dengan fitur target menggunakan fungsi corr()
"""

sns.pairplot(car, diag_kind='kde')

"""pada fitur numerikal diatas dapat dilihat bahwa tidak ada yang memiliki korelasi yang tinggi terhadap fitur 'price'"""

plt.figure(figsize=(10,8))
correlation_matrics = car.corr().round(2)
# annot = True to print the values inside the square
sns.heatmap(data=correlation_matrics, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('correlation Matrix untuk fitur Numerik', size=20)

"""fitur ‘tax’, ‘year, dan ‘engineSize’ memiliki skor korelasi yang sedang (di antara 0.5 - 0.6) dengan fitur target ‘price’. Artinya, fitur 'price' berkorelasi sedang dengan ketiga fitur tersebut. Sementara itu, fitur ‘mileage’  dan 'mpg' memiliki korelasi yang sangat kecil (antara -5 hingga -7). Sehingga, fitur tersebut dapat di-drop."""

car.drop(['mileage'], inplace=True, axis=1)
car.drop(['mpg'], inplace=True, axis=1)
car.head()

"""### DATA PREPARATION 
Menggunakan oneHotEncoder
"""

car = pd.concat([car, pd.get_dummies(car['model'], prefix='model', drop_first=True)], axis=1)
car = pd.concat([car, pd.get_dummies(car['transmission'], prefix='transmission', drop_first=True)], axis=1)
car = pd.concat([car, pd.get_dummies(car['fuelType'], prefix='fuelType', drop_first=True)], axis=1)
car.drop(['model','transmission','fuelType'], axis=1, inplace=True)
car.head()

"""**reduksi dimensi dengan PCA**"""

sns.pairplot(car[['engineSize','tax']], plot_kws={'s':2})

"""Aplikasikan class PCA"""

pca = PCA(n_components=2, random_state=123)
pca.fit(car[['engineSize','tax']])
princ_comp = pca.transform(car[['engineSize','tax']])

"""Mengetahui informasi dari ke dua komponen"""

pca.explained_variance_ratio_.round(3)

"""Membuat fitur bernama 'fitur'"""

pca = PCA(n_components=1, random_state=123)
pca.fit(car[['engineSize','tax']])
car['fitur'] = pca.transform(car.loc[:, ('engineSize','tax')]).flatten()
car.drop(['engineSize','tax'], axis=1, inplace=True)

"""**TRAIN TEST SPLIT**

Membagi data latih dan data uji
"""

X = car.drop(['price'], axis=1)
y = car['price']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=123)

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""**STANDARISASI**"""

numerik = ['year','fitur']
scaler = StandardScaler()
scaler.fit(X_train[numerik])
X_train[numerik] = scaler.transform(X_train.loc[:, numerik])
X_train[numerik].head()

"""cek nilai mean dan standar deviasi  setelah proses standarisasi"""

X_train[numerik].describe().round(4)

"""## Modeling

Proses modeling yang saya lakukan pada data ini adalah dengan menggabungkan tiga algoritma machine learning kemudian dicari performa yang paling baik dari ketiga algoritma machine learning tersebut.

## Model Development dengan K-Nearest Neighbor

persiapan dataframe untuk analisis model
"""

models = pd.DataFrame(index=['train_mse','test_mse'],
                    columns=['KNN', 'RandomForest', 'Boosting'])

"""Cara penulisan kode K-Nearest Neigbor ialah sebagai berikut :"""

knn = KNeighborsRegressor(n_neighbors=10)
knn.fit(X_train, y_train)
y_pred_knn = knn.predict(X_train)

"""## Model Development dengan Random Forest"""

# buat model prediksi
RF = RandomForestRegressor(n_estimators=45, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)

models.loc['train_mse','RandomForest'] = mean_squared_error(y_pred=RF.predict(X_train), y_true=y_train)

"""## Model Development dengan Boosting Algorithm"""

boosting = AdaBoostRegressor(n_estimators=50, learning_rate=0.05, random_state=55)
boosting.fit(X_train, y_train)
models.loc['train_mse','Boosting'] = mean_squared_error(y_pred=boosting.predict(X_train), y_true=y_train)
X_test.loc[:, numerik] = scaler.transform(X_test[numerik])

"""## Evaluation

Evaluasi metrik yang digunakan untuk mengukur kinerja model adalah metrik mse (Mean Squared Error), karena kasus yang saya pilih merupakan kasus regresi.

MSE pada dasarnya mengukur kesalahan kuadrat rata-rata dari prediksi kita. Untuk setiap poin, dia menghitung selisih kuadrat antara prediksi dan target kemudian merata-rata nilai-nilai itu.

makin tinggi nilai ini, makin buruk modelnya. Nilai MSE tidak pernah negatif, karena kita menguadratkan kesalahan prediksi individu sebelum menjumlahkannya, tetapi akan menjadi nol untuk model yang sempurna.

Keuntungan: Berguna jika kita memiliki nilai tak terduga yang harus kita pedulikan. Nilai sangat tinggi atau rendah yang harus kita perhatikan.<br>

Kerugian: Jika kita membuat satu prediksi yang sangat buruk, kuadrat akan membuat kesalahan lebih buruk dan itu mungkin membuat metrik cenderung melebih-lebihkan keburukan model. Itu adalah perilaku yang sangat bermasalah jika kita memiliki data yang noisy (yaitu, data yang karena alasan apa pun tidak sepenuhnya dapat diandalkan) bahkan model "sempurna" mungkin memiliki MSE tinggi dalam situasi itu, sehingga menjadi sulit untuk menilai seberapa baik model sedang melakukan. Di sisi lain, jika semua kesalahan kecil, atau lebih tepatnya, lebih kecil dari 1, dari efek sebaliknya dirasakan: kita dapat meremehkan keburukan model.

formula dari metrik MSE adalah sebagai berikut

![formula metrik MSE](https://raw.githubusercontent.com/onedayxzn/submission_file/master/2021071619431112f1106e20559e77c855cea11d1b1479.jpeg?token=AOCWOZU6LNKVCXTMU7HOR3DBLVCWU)

keterangan : <br>
N : Jumlah dataset. <br>
yi = nilai sebenarnya.<br>
y_pred = nilai prediksi.<br>

Evaluasi ketiga model dengan matrix mse
"""

mse = pd.DataFrame(columns=['train','test'],index=['KNN','RF','boosting'])
model_dict = {'KNN':knn, 'RF':RF, 'boosting': boosting}
for name, model in model_dict.items():
    mse.loc[name, 'train'] = mean_squared_error(y_true=y_train, y_pred=model.predict(X_train))/1e3
    mse.loc[name, 'test'] = mean_squared_error(y_true=y_test, y_pred=model.predict(X_test))/1e3
mse

"""menampilkan plot metrix dengan bar chart"""

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

"""Dari gambar diatas memperlihatkan bahwa RF memberikan nilai error yang paling kecil. maka model RF dipilih sebagai model terbaik untuk melakukan prediksi harga rumah

Berikut adalah kode untuk melihat hasil predikisi dari masing-masing model
"""

prediksi = X_test.iloc[:1].copy()
pred_dict = {'y_true':y_test[:1]}
for name, model in model_dict.items():
    pred_dict['prediksi_'+name] = model.predict(prediksi).round(1)

pd.DataFrame(pred_dict)

"""dapat dilihat diatas bahwa prediki dengan RF memberikan hasil yang paling mendekati dibanding dengan kedua model lainnya"""